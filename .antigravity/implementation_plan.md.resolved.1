# Implementation Plan: Public Registration & Customer Portal

## Problem Statement

The current multi-tenant ISP system lacks public customer registration and a customer-facing portal. Customers must be created manually by admins, and there's no way for customers to self-register or access their own data. Additionally, MikroTik provisioning is done synchronously during customer creation, blocking the API.

## Goals

1. **Public Registration**: Allow customers to self-register via a public slug-based endpoint
2. **Customer Portal**: Provide authenticated customer portal for viewing traffic, profile, and session management
3. **Async Provisioning**: Use RabbitMQ workers to handle MikroTik provisioning asynchronously
4. **Traffic Aggregation**: Cache real-time traffic data in Redis for efficient customer portal access

---

## User Review Required

> [!IMPORTANT]
> **Credential Separation Strategy**: Customer portal login credentials (email + password) are **completely separate** from service credentials (PPPoE/Hotspot username + password):
> - **Portal Login**: Customer chooses email + password for accessing the customer portal
> - **PPPoE Credentials**: Auto-generated by system, **customer never sees the password** (security best practice)
> - **Hotspot Credentials**: Can be visible to customer (less sensitive, often used on shared devices)
> - All three credential types are stored separately in the database

> [!WARNING]
> **Breaking Change - Provisioning Flow**: The [ApproveProspect](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/domain/customer/domain.go#535-682) method will be refactored to publish a RabbitMQ message instead of directly calling MikroTik API. This means approvals will be asynchronous. The UI will need to handle "provisioning in progress" status.

> [!CAUTION]
> **Service Credential Auto-Generation**: For PPPoE, the service username and password will be auto-generated during provisioning (not during registration). This ensures PPPoE credentials are system-managed and secure.

---

## Proposed Changes

### Component: Database Layer

#### [MODIFY] [01_init_system.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/migration/postgres/01_init_system.go)

Update ENUMs to include customer role:
- Add `'customer'` to `user_role` enum
- This allows customers to be represented in the same users table if needed

#### [NEW] 14_customer_portal_support.go

New migration to support customer portal:
- Add `password_hash` column to `customers` table (TEXT, nullable for existing records)
- Create `customer_sessions` table for storing customer auth sessions
  - Structure: `id UUID`, `customer_id UUID`, `tenant_id UUID`, `token_hash TEXT`, `refresh_token_hash TEXT`, `expires_at TIMESTAMPTZ`, `created_at TIMESTAMPTZ`
  - Indexes: `customer_id`, `tenant_id`, `token_hash`
- Add email index on `customers` table for login
- Add `provisioning_status` ENUM: `'pending'`, `'provisioning'`, `'active'`, `'failed'`
- Add `provisioning_error` TEXT column to `customers` for error messages

---

### Component: Models

#### [MODIFY] [customer.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/model/customer.go)

Add new models:
- `CustomerLoginRequest` - for customer portal login (username/email + password)
- `CustomerLoginResponse` - JWT token response
- `CustomerPortalTrafficResponse` - traffic data from Redis
- `CustomerSessionResetRequest` - for resetting PPP/Hotspot sessions
- Update [Customer](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/model/customer.go#31-61) struct with `PasswordHash *string` field
- Update [PublicRegistrationRequest](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/model/customer.go#208-219) - ensure password validation is included

#### [NEW] customer_auth.go

Create customer authentication models:
- `CustomerSession` - mirrors UserSession but for customers
- `CustomerTokenMetadata` - JWT claims for customer tokens

---

### Component: Repository Layer (Outbound Ports & Adapters)

#### [MODIFY] [customer.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/port/outbound/customer.go)

Add to `CustomerDatabasePort` interface:
- `GetByUsernameOrEmail(ctx context.Context, tenantID uuid.UUID, identifier string) (*model.Customer, error)`
- `UpdatePasswordHash(ctx context.Context, customerID uuid.UUID, passwordHash string) error`
- `UpdateProvisioningStatus(ctx context.Context, customerID uuid.UUID, status, errorMsg string) error`

#### [MODIFY] [customer.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/adapter/outbound/postgres/customer.go)

Implement new repository methods:
- `GetByUsernameOrEmail` - look up customer by username OR email
- `UpdatePasswordHash` - for storing hashed password
- `UpdateProvisioningStatus` - update provisioning workflow status
- Update `CreateProspect` to accept and store password hash

#### [NEW] customer_session.go (Port & Adapter)

Create customer session repository:
- Port interface in `internal/port/outbound/customer_session.go`
- Adapter implementation in `internal/adapter/outbound/redis/customer_session.go`
- Methods: `CreateSession`, `GetSession`, `DeleteSession`, `RefreshSession`
- Use Redis with TTL (similar to existing auth session)

#### [MODIFY] [tenant.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/port/outbound/tenant.go)

Add to `TenantDatabasePort`:
- `GetBySlug(ctx context.Context, slug string) (*model.Tenant, error)`
- `GetPublicInfo(ctx context.Context, slug string) (*model.TenantPublicResponse, error)`

#### [MODIFY] [tenant.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/adapter/outbound/postgres/tenant.go)

Implement:
- `GetBySlug` - retrieve tenant by slug
- `GetPublicInfo` - return only public branding information (name, logo, features)

---

### Component: Domain Layer

#### [MODIFY] [customer/domain.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/domain/customer/domain.go)

Update existing methods:
- [RegisterProspect](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/domain/customer/domain.go#420-510): Add password hashing using bcrypt, store hash in database
- [ApproveProspect](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/domain/customer/domain.go#535-682): **REMOVE direct MikroTik API call**, instead publish message to RabbitMQ
  - Message format: `{customer_id, tenant_id, profile_id, password_hash, service_type}`
  - Update customer status to "provisioning"
  
Reasons:
- Keeps API responsive during provisioning
- Allows worker retries on failure
- Better error handling and logging

#### [NEW] customer_portal/domain.go

New domain service for customer portal operations:
- `CustomerLogin(ctx, request) (*CustomerSession, error)` - authenticate and create session
- `CustomerLogout(ctx, customerID) error` - invalidate session
- `RefreshToken(ctx, refreshToken) (*CustomerSession, error)` - refresh JWT
- `GetTrafficStats(ctx, customerID) (*TrafficData, error)` - fetch from Redis cache
- `ResetSession(ctx, customerID) error` - publish disconnect task to RabbitMQ

Dependencies: `DatabasePort`, `CachePort`, `MessagePort` (RabbitMQ)

---

### Component: RabbitMQ Workers

#### [NEW] provisionin g_worker.go

Location: `internal/adapter/inbound/rabbitmq/provisioning_worker.go`

Worker responsibilities:
1. Subscribe to `customer.provisioning` queue (fanout exchange)
2. On message received:
   - Parse message (customer_id, tenant_id, profile_id, password_hash, service_type)
   - Get tenant's MikroTiks (max 3)
   - Select optimal MikroTik (round-robin or least-loaded)
   - Execute RouterOS API `/ppp/secret/add` or hotspot user add
   - On success: Update customer status to "active", store mikrotik_id and mikrotik_object_id
   - On failure: Update status to "failed", store error message, retry with exponential backoff
3. ACK message on success, NACK on retryable failures

#### [NEW] disconnect_worker.go

Location: `internal/adapter/inbound/rabbitmq/disconnect_worker.go`

Worker for session resets:
1. Subscribe to `customer.disconnect` queue
2. On message: Execute `/ppp/active/remove` or hotspot logout
3. Update customer last_online timestamp

#### [MODIFY] [route.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/adapter/inbound/rabbitmq/route.go)

Add worker routes:
- `provisioning` - start provisioning worker
- `disconnect` - start disconnect worker

#### [MODIFY] [app.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/app.go)

Start workers on application startup (goroutines):
```go
go rabbitmq_adapter.StartProvisioningWorker(ctx, domainRegistry)
go rabbitmq_adapter.StartDisconnectWorker(ctx, domainRegistry)
```

---

### Component: Traffic Aggregation Service

#### [NEW] traffic_aggregator/service.go

Location: `internal/domain/traffic_aggregator/service.go`

Background service:
- Subscribe to Redis PubSub channel `mikrotik:traffic:customers` (already published by Monitor domain)
- Aggregate traffic per customer per minute
- Store in Redis with key pattern: `traffic:customer:{customer_id}:{timestamp}`
- Use Redis sorted sets for time-series: `traffic:customer:{customer_id}:history`
  - Score: Unix timestamp
  - Value: JSON traffic data
- Set TTL: 24 hours
- Provide methods:
  - `GetLatestTraffic(customerID) (*TrafficData, error)`
  - `GetTrafficHistory(customerID, from, to time.Time) ([]TrafficData, error)`

Start as background goroutine in [app.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/app.go).

---

### Component: HTTP Layer (Inbound Adapters)

#### [NEW] customer_auth.go

Location: `internal/adapter/inbound/gin/customer_auth.go`

HTTP handlers:
- `CustomerLogin(c *gin.Context)` - POST `/v1/customer/auth/login`
- `CustomerLogout(c *gin.Context)` - POST `/v1/customer/auth/logout`
- `RefreshToken(c *gin.Context)` - POST `/v1/customer/auth/refresh`
- `GetProfile(c *gin.Context)` - GET `/v1/customer/auth/profile`

#### [NEW] customer_portal.go

Location: `internal/adapter/inbound/gin/customer_portal.go`

HTTP handlers:
- `GetTrafficStats(c *gin.Context)` - GET `/v1/customer/portal/traffic`
- [StreamTraffic(c *gin.Context)](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/domain/monitor/service.go#37-110) - GET `/v1/customer/portal/traffic/stream` (WebSocket)
- `ResetSession(c *gin.Context)` - POST `/v1/customer/portal/session/reset`
- `GetUsageHistory(c *gin.Context)` - GET `/v1/customer/portal/usage/history`
- `UpdateProfile(c *gin.Context)` - PUT `/v1/customer/portal/profile` (name, phone, address only)

#### [NEW] public_registration.go

Location: `internal/adapter/inbound/gin/public_registration.go`

HTTP handlers:
- `GetTenantInfo(c *gin.Context)` - GET `/v1/public/tenant/:slug`
  - Returns branding info (name, logo, available profiles)
- `PublicRegister(c *gin.Context)` - POST `/v1/public/register/:slug`
  - Create prospect with password hash
  - Return success message (awaiting approval)

#### [MODIFY] [route.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/adapter/inbound/gin/route.go)

Add routes:

**Public routes (no auth):**
```go
public.GET("/tenant/:slug", port.PublicRegistration().GetTenantInfo)
public.POST("/register/:slug", port.PublicRegistration().PublicRegister)
```

**Customer auth routes:**
```go
customerAuth := v1.Group("/customer/auth")
customerAuth.POST("/login", port.CustomerAuth().CustomerLogin)
customerAuth.POST("/logout", middlewareAdapter.CustomerAuth, port.CustomerAuth().CustomerLogout)
customerAuth.POST("/refresh", port.CustomerAuth().RefreshToken)
customerAuth.GET("/profile", middlewareAdapter.CustomerAuth, port.CustomerAuth().GetProfile)
```

**Customer portal routes (require CustomerAuth middleware):**
```go
portal := v1.Group("/customer/portal")
portal.Use(middlewareAdapter.CustomerAuth())
{
  portal.GET("/traffic", port.CustomerPortal().GetTrafficStats)
  portal.GET("/traffic/stream", port.CustomerPortal().StreamTraffic)
  portal.POST("/session/reset", port.CustomerPortal().ResetSession)
  portal.GET("/usage/history", port.CustomerPortal().GetUsageHistory)
  portal.PUT("/profile", port.CustomerPortal().UpdateProfile)
}
```

---

### Component: Middleware

#### [MODIFY] [middleware.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/adapter/inbound/gin/middleware.go)

Add new middleware:
- `CustomerAuth() gin.HandlerFunc`
  - Validate customer JWT token
  - Extract customer_id and tenant_id from token
  - Inject into Gin context
  - Verify customer status is "active"
  - Ensure tenant isolation (customer can only access their tenant's data)

Update existing:
- Ensure `TenantContext` middleware doesn't conflict with CustomerAuth

---

### Component: Redis Cache Keys

#### [NEW] traffic_cache_keys.go

Location: `internal/adapter/outbound/redis/traffic_cache_keys.go`

Define keys:
- `CacheTrafficLatest = "traffic:customer:%s:latest"` - latest traffic for customer
- `CacheTrafficHistory = "traffic:customer:%s:history"` - sorted set for historical data
- `CacheTrafficLive = "traffic:customer:%s:live"` - current live stream subscribers

---

## Verification Plan

### Automated Tests

#### 1. Unit Tests - Customer Domain

**File**: [internal/domain/customer/domain_test.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/domain/customer/domain_test.go)

Test scenarios to add:
- `TestRegisterProspect_WithPasswordHash` - Verify password is hashed and stored
- `TestApproveProspect_PublishesToRabbitMQ` - Mock RabbitMQ, verify message published
- `TestApproveProspect_SetsProvisioningStatus` - Verify status updated to "provisioning"

**Run command**:
```bash
cd internal/domain/customer
go test -v -run "TestRegisterProspect|TestApproveProspect"
```

#### 2. Unit Tests - Customer Portal Domain

**File**: `internal/domain/customer_portal/domain_test.go` (NEW)

Test scenarios:
- `TestCustomerLogin_ValidCredentials` - Successful login
- `TestCustomerLogin_InvalidPassword` - Login fails with wrong password
- `TestCustomerLogin_InactiveCustomer` - Cannot login if status != 'active'
- `TestGetTrafficStats_FetchFromRedis` - Verify Redis cache hit

**Run command**:
```bash
cd internal/domain/customer_portal
go test -v
```

#### 3. Integration Tests - Provisioning Worker

**File**: `internal/adapter/inbound/rabbitmq/provisioning_worker_test.go` (NEW)

Requires: Running RabbitMQ and PostgreSQL (test containers or docker-compose)

Test scenarios:
- Publish provisioning message
- Verify worker picks up message
- Mock MikroTik API to return success
- Verify customer status updated correctly

**Run command**:
```bash
# Start test dependencies
docker-compose -f docker-compose.test.yml up -d

# Run integration tests
go test -v ./internal/adapter/inbound/rabbitmq/... -tags=integration
```

### Manual Testing

#### 1. Public Registration Flow

1. Start the application: `make run`
2. Get tenant info:
   ```bash
   curl -X GET http://localhost:8080/v1/public/tenant/demo-tenant
   ```
   **Expected**: Returns tenant branding and available profiles
   
3. Register as prospect:
   ```bash
   curl -X POST http://localhost:8080/v1/public/register/demo-tenant \
     -H "Content-Type: application/json" \
     -d '{
       "username": "testuser",
       "password": "securepass123",
       "name": "Test User",
       "phone": "081234567890",
       "email": "test@example.com",
       "profile_id": "uuid-of-profile",
       "service_type": "pppoe"
     }'
   ```
   **Expected**: Status 201, returns prospect created, status="prospect"

4. Admin approves prospect via internal API (already exists):
   ```bash
   curl -X POST http://localhost:8080/v1/internal/customer/prospects/approve \
     -H "Authorization: Bearer {admin-token}" \
     -H "Content-Type: application/json" \
     -d '{
       "customer_id": "prospect-uuid",
       "billing_day": 1,
       "auto_suspension": true
     }'
   ```
   **Expected**: Status 200, customer status="provisioning"

5. Check RabbitMQ management UI: Verify message in `customer.provisioning` queue

6. Check customer status after ~5 seconds:
   ```bash
   curl -X GET http://localhost:8080/v1/internal/customer/{id} \
     -H "Authorization: Bearer {admin-token}"
   ```
   **Expected**: Status="active", mikrotik_object_id populated

#### 2. Customer Portal Login & Traffic

1. Customer logs in:
   ```bash
   curl -X POST http://localhost:8080/v1/customer/auth/login \
     -H "Content-Type: application/json" \
     -d '{
       "username": " testuser",
       "password": "securepass123"
     }'
   ```
   **Expected**: Returns JWT access_token and refresh_token

2. Get traffic stats:
   ```bash
   curl -X GET http://localhost:8080/v1/customer/portal/traffic \
     -H "Authorization: Bearer {customer-token}"
   ```
   **Expected**: Returns latest traffic data from Redis

3. Reset session:
   ```bash
   curl -X POST http://localhost:8080/v1/customer/portal/session/reset \
     -H "Authorization: Bearer {customer-token}"
   ```
   **Expected**: Status 200, customer's PPP session disconnected

#### 3. Security & Isolation Testing

1. Customer A logs in, gets token
2. Customer A tries to access Customer B's data:
   ```bash
   curl -X GET http://localhost:8080/v1/customer/portal/traffic \
     -H "Authorization: Bearer {customer-a-token}" \
     -H "X-Customer-ID: {customer-b-id}"
   ```
   **Expected**: Status 403 Forbidden (middleware blocks cross-customer access)

3. Customer from Tenant A tries to login with credentials from Tenant B:
   **Expected**: Status 401 Unauthorized (tenant isolation enforced)

---

## Redis Cache Strategy

**Traffic Data Aggregation**:
1. Monitor domain publishes to `mikrotik:traffic:customers` (already implemented)
2. Traffic Aggregator subscribes and processes:
   - Stores latest: `traffic:customer:{id}:latest` (hash, TTL 5 min)
   - Stores history: `traffic:customer:{id}:history` (sorted set by timestamp, TTL 24h)
3. Customer Portal reads from cache (fast, no MikroTik query needed)

**Session Storage**:
- Key: `customer:session:{token_hash}`
- Value: JSON {customer_id, tenant_id, expires_at}
- TTL: Same as JWT expiry

---

## Security Considerations

1. **Password Hashing**: Use bcrypt with cost 12 for customer passwords
2. **JWT Tokens**: Separate signing key for customer tokens vs admin tokens
3. **Rate Limiting**: 
   - Public registration: 5 requests per IP per hour
   - Customer login: 10 attempts per username per hour
4. **Tenant Isolation**: 
   - Middleware MUST verify customer.tenant_id matches JWT tenant claim
   - Database queries MUST include tenant_id filter
5. **Input Validation**: All public endpoints have strict validation (already using Gin binding)

---

## Migration Plan

1. Run migration `14_customer_portal_support.go`
2. Restart application (workers start automatically)
3. Existing prospects: One-time script to reset them (password hash missing) OR require re-registration
4. Monitor RabbitMQ queues to ensure workers are consuming

---

## Rollback Strategy

If issues arise:
1. Revert migration `14_customer_portal_support.go`
2. Comment out worker startup in [app.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/app.go)
3. Revert [ApproveProspect](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/domain/customer/domain.go#535-682) to direct MikroTik API call (keep synchronous)
4. Remove customer portal routes from [route.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/adapter/inbound/gin/route.go)
