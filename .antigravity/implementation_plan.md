# Implementation Plan: Public Registration & Customer Portal

## Problem Statement

The current multi-tenant ISP system lacks public customer registration and a customer-facing portal. Customers must be created manually by admins, and there's no way for customers to self-register or access their own data. Additionally, MikroTik provisioning is done synchronously during customer creation, blocking the API.

## Goals

1. **Public Registration**: Allow customers to self-register via a public slug-based endpoint
2. **Customer Portal**: Provide authenticated customer portal for viewing traffic, profile, and session management
3. **Async Provisioning**: Use RabbitMQ workers to handle MikroTik provisioning asynchronously
4. **Traffic Aggregation**: Cache real-time traffic data in Redis for efficient customer portal access

---

## User Review Required

> [!IMPORTANT]
> **Credential Separation Strategy**: Customer portal login credentials (email + password) are **completely separate** from service credentials (PPPoE/Hotspot username + password):
> - **Portal Login**: Customer chooses email + password for accessing the customer portal
> - **PPPoE Credentials**: Auto-generated by system, **customer never sees the password** (security best practice)
> - **Hotspot Credentials**: Can be visible to customer (less sensitive, often used on shared devices)
> - All three credential types are stored separately in the database

> [!WARNING]
> **Breaking Change - Provisioning Flow**: The `ApproveProspect` method will be refactored to publish a RabbitMQ message instead of directly calling MikroTik API. This means approvals will be asynchronous. The UI will need to handle "provisioning in progress" status.

> [!CAUTION]
> **Service Credential Auto-Generation**: For PPPoE, the service username and password will be auto-generated during provisioning (not during registration). This ensures PPPoE credentials are system-managed and secure.

---

## Proposed Changes

### Component: Database Layer

#### [MODIFY] [01_init_system.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/migration/postgres/01_init_system.go)

Update ENUMs to include customer role:
- Add `'customer'` to `user_role` enum
- This allows customers to be represented in the same users table if needed

#### [NEW] 14_customer_portal_credentials.go

New migration to support **separate** portal and service credentials:

**Portal Login Credentials** (for customer portal access):
- Add `portal_email` column to `customers` table (VARCHAR(255), UNIQUE per tenant, NOT NULL)
- Add `portal_password_hash` column to `customers` table (TEXT, NOT NULL)
- Add index on `portal_email` for fast login lookup
- Add UNIQUE constraint: `UNIQUE(tenant_id, portal_email, deleted_at)`

**Service Credentials** (for PPPoE/Hotspot):
- Rename existing `username` â†’ `service_username` (for clarity)
- Add `service_password_encrypted` column (TEXT, nullable)
  - For PPPoE: encrypted auto-generated password (customer never sees)
  - For Hotspot: encrypted customer-chosen password (can be decrypted and shown)
- Add `service_password_visible` column (BOOLEAN, default FALSE)
  - TRUE for Hotspot (customer can view in portal)
  - FALSE for PPPoE (system-managed, hidden)

**Session Management**:
- Create `customer_sessions` table for storing customer portal sessions
  - `id UUID PRIMARY KEY`
  - `customer_id UUID NOT NULL REFERENCES customers(id)`
  - `tenant_id UUID NOT NULL` (for isolation)
  - `token_hash TEXT NOT NULL`
  - `refresh_token_hash TEXT`
  - `ip_address INET`
  - `user_agent TEXT`
  - `expires_at TIMESTAMPTZ NOT NULL`
  - `created_at TIMESTAMPTZ DEFAULT NOW()`
  - Indexes: `customer_id`, `tenant_id`, `token_hash`

**Provisioning Status**:
- Add `provisioning_status` ENUM: `'pending'`, `'provisioning'`, `'active'`, `'failed'`
- Add `provisioning_error` TEXT column
- Add `provisioned_at` TIMESTAMPTZ column

---

### Component: Models

#### [MODIFY] [customer.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/model/customer.go)

Update `Customer` struct with **separated credentials**:
```go
// Portal Login Credentials (for customer portal access)
PortalEmail        string  `gorm:"type:varchar(255);not null" json:"portal_email"`
PortalPasswordHash string  `gorm:"type:text;not null" json:"-"`

// Service Credentials (for PPPoE/Hotspot)
ServiceUsername         string  `gorm:"type:varchar(100);not null" json:"service_username"`
ServicePasswordEncrypted *string `gorm:"type:text" json:"-"`
ServicePasswordVisible  bool    `gorm:"default:false" json:"-"` 

// Provisioning
ProvisioningStatus string  `gorm:"type:varchar(20);default:'pending'" json:"provisioning_status"`
ProvisioningError  *string `gorm:"type:text" json:"provisioning_error,omitempty"`
ProvisionedAt      *time.Time `json:"provisioned_at,omitempty"`
```

Add new request models:
- `CustomerLoginRequest` - portal login (email + password)
- `CustomerLoginResponse` - JWT tokens
- `CustomerPortalProfileResponse` - includes service username (visible for hotspot only)
- `CustomerSessionResetRequest` - reset PPP/Hotspot session

Update existing models:
- `PublicRegistrationRequest`:
  - Add `portal_email` and `portal_password` (for portal access)
  - Remove `password` field (service credentials will be auto-generated)
  - For Hotspot: optionally allow `service_password` input
  - For PPPoE: service credentials auto-generated by system

#### [NEW] customer_auth.go

Create customer authentication models:
- `CustomerSession` - mirrors UserSession but for customers
- `CustomerTokenMetadata` - JWT claims for customer tokens

---

### Component: Repository Layer (Outbound Ports & Adapters)

#### [MODIFY] [customer.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/port/outbound/customer.go)

Add to `CustomerDatabasePort` interface:
- `GetByPortalEmail(ctx context.Context, tenantID uuid.UUID, email string) (*model.Customer, error)` - for portal login
- `GetByServiceUsername(ctx context.Context, tenantID uuid.UUID, username string) (*model.Customer, error)` - for service lookup
- `UpdatePortalPassword(ctx context.Context, customerID uuid.UUID, passwordHash string) error`
- `UpdateServiceCredentials(ctx context.Context, customerID uuid.UUID, username, encryptedPassword string, visible bool) error`
- `UpdateProvisioningStatus(ctx context.Context, customerID uuid.UUID, status, errorMsg string) error`

#### [MODIFY] [customer.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/adapter/outbound/postgres/customer.go)

Implement new repository methods:
- `GetByPortalEmail` - lookup by portal_email field (for customer login)
- `GetByServiceUsername` - lookup by service_username (for MikroTik callbacks)
- `UpdatePortalPassword` - update portal_password_hash only
- `UpdateServiceCredentials` - set service_username, service_password_encrypted, service_password_visible
- `UpdateProvisioningStatus` - update provisioning workflow status
- Update `CreateProspect` to:
  - Store portal_email and portal_password_hash
  - Leave service credentials NULL (will be set during provisioning)

#### [NEW] customer_session.go (Port & Adapter)

Create customer session repository:
- Port interface in `internal/port/outbound/customer_session.go`
- Adapter implementation in `internal/adapter/outbound/redis/customer_session.go`
- Methods: `CreateSession`, `GetSession`, `DeleteSession`, `RefreshSession`
- Use Redis with TTL (similar to existing auth session)

#### [MODIFY] [tenant.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/port/outbound/tenant.go)

Add to `TenantDatabasePort`:
- `GetBySlug(ctx context.Context, slug string) (*model.Tenant, error)`
- `GetPublicInfo(ctx context.Context, slug string) (*model.TenantPublicResponse, error)`

#### [MODIFY] [tenant.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/adapter/outbound/postgres/tenant.go)

Implement:
- `GetBySlug` - retrieve tenant by slug
- `GetPublicInfo` - return only public branding information (name, logo, features)

---

### Component: Domain Layer

#### [MODIFY] [customer/domain.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/domain/customer/domain.go)

Update existing methods:

**`RegisterProspect` (Portal Credential Registration)**:
- Accept `portal_email` and `portal_password` from request
- Hash `portal_password` using bcrypt (cost 12)
- Store `portal_email` and `portal_password_hash` in database
- **Do NOT** set service credentials yet (service_username and service_password remain NULL)
- Customer status: `'prospect'`

**`ApproveProspect` (Service Credential Generation + Provisioning)**:
- **REMOVE direct MikroTik API call**
- Generate service credentials based on service_type:
  - **For PPPoE**:
    - Generate unique service_username (e.g., `pppoe_{customer_id_short}` or `{tenant_prefix}_{counter}`)
    - Generate strong random service_password (16 chars, alphanumeric)
    - Set `service_password_visible = FALSE` (customer will NEVER see this)
  - **For Hotspot**:
    - Generate or use customer-provided service_username
    - Generate service_password (simpler, 8 chars)
    - Set `service_password_visible = TRUE` (customer can view in portal)
- Encrypt service_password using AES-256 before storing
- Update customer with service credentials in database
- Publish RabbitMQ message: `{customer_id, tenant_id, profile_id, service_username, service_password_plain, service_type}`
- Update status to `'provisioning'`

**Security Note**: Service password is encrypted (not hashed) so it can be decrypted for:
- Sending to MikroTik API (plain text required)
- Showing to customer (Hotspot only, if `service_password_visible = TRUE`)

#### [NEW] customer_portal/domain.go

New domain service for customer portal operations:

**Authentication** (uses portal credentials):
- `CustomerLogin(ctx, email, password) (*CustomerSession, error)`
  - Lookup by `portal_email`
  - Verify against `portal_password_hash` (bcrypt)
  - Create JWT with claims: {customer_id, tenant_id, email}
  - Store session in Redis
- `CustomerLogout(ctx, customerID) error` - invalidate session
- `RefreshToken(ctx, refreshToken) (*CustomerSession, error)` - refresh JWT

**Profile Management**:
- `GetProfile(ctx, customerID) (*CustomerProfile, error)`
  - Return basic info + service credentials (if visible)
  - For PPPoE: show only service_username, hide password
  - For Hotspot: show both service_username and decrypted service_password
- `UpdateProfile(ctx, customerID, request) error`
  - Allow updating: name, phone, address, portal_password
  - **Cannot** update service credentials (system-managed)

**Usage & Traffic**:
- `GetTrafficStats(ctx, customerID) (*TrafficData, error)` - fetch from Redis cache
- `GetUsageHistory(ctx, customerID, from, to) ([]UsageData, error)`

**Session Control**:
- `ResetSession(ctx, customerID) error`
  - Publish disconnect task to RabbitMQ
  - Worker will execute `/ppp/active/remove` using service_username (not portal email)

Dependencies: `DatabasePort`, `CachePort`, `MessagePort`, `EncryptionService`

---

---

### Component: Encryption Service (Utility)

#### [NEW] encryption/service.go

Location: `utils/encryption/service.go`

Service for encrypting/decrypting service credentials:
- `Encrypt(plaintext string) (string, error)` - AES-256-GCM encryption
- `Decrypt(ciphertext string) (string, error)` - AES-256-GCM decryption
- Use environment variable `SERVICE_CREDENTIAL_KEY` (32 bytes) as encryption key
- Return base64-encoded ciphertext for storage

**Why Encryption (not hashing)**:
- Service passwords must be sent to MikroTik API in plain text
- Hotspot passwords must be decryptable to show to customers (if visible)
- Portal passwords use bcrypt (one-way hash) because they're never decrypted

**Security**:
- Encryption key stored in environment variable (not in code/database)
- Use separate key from JWT secret
- Rotate key periodically (requires re-encryption migration)

---

### Component: RabbitMQ Workers

#### [NEW] provisionin g_worker.go

Location: `internal/adapter/inbound/rabbitmq/provisioning_worker.go`

Worker responsibilities:
1. Subscribe to `customer.provisioning` queue (fanout exchange)
2. On message received:
   - Parse message: `{customer_id, tenant_id, profile_id, service_username, service_password, service_type}`
   - Get tenant's MikroTiks (max 3)
   - Select optimal MikroTik (round-robin or least-loaded)
   - Execute RouterOS API with **service credentials**:
     - For PPPoE: `/ppp/secret/add name={service_username} password={service_password} profile={profile_name}`
     - For Hotspot: `/ip/hotspot/user/add name={service_username} password={service_password} profile={profile_name}`
   - On success:
     - Update customer status to `'active'`
     - Store `mikrotik_id` and `mikrotik_object_id`
     - Set `provisioned_at = NOW()`
   - On failure:
     - Update status to `'failed'`
     - Store error in `provisioning_error`
     - Retry with exponential backoff (max 3 attempts)
3. ACK message on success, NACK on retryable failures

**Important**: Worker uses `service_username` and `service_password` (NOT portal credentials)

#### [NEW] disconnect_worker.go

Location: `internal/adapter/inbound/rabbitmq/disconnect_worker.go`

Worker for session resets:
1. Subscribe to `customer.disconnect` queue
2. On message received: `{customer_id, service_username, service_type}`
3. Get customer's assigned MikroTik
4. Execute MikroTik API with **service credentials**:
   - For PPPoE: `/ppp/active/remove numbers=[find name={service_username}]`
   - For Hotspot: `/ip/hotspot/active/remove numbers=[find user={service_username}]`
5. Update customer `last_online` timestamp
6. ACK message

**Important**: Uses `service_username` to identify the active session (NOT portal email)

#### [MODIFY] [route.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/adapter/inbound/rabbitmq/route.go)

Add worker routes:
- `provisioning` - start provisioning worker
- `disconnect` - start disconnect worker

#### [MODIFY] [app.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/app.go)

Start workers on application startup (goroutines):
```go
go rabbitmq_adapter.StartProvisioningWorker(ctx, domainRegistry)
go rabbitmq_adapter.StartDisconnectWorker(ctx, domainRegistry)
```

---

### Component: Traffic Aggregation Service

#### [NEW] traffic_aggregator/service.go

Location: `internal/domain/traffic_aggregator/service.go`

Background service:
- Subscribe to Redis PubSub channel `mikrotik:traffic:customers` (already published by Monitor domain)
- Aggregate traffic per customer per minute
- Store in Redis with key pattern: `traffic:customer:{customer_id}:{timestamp}`
- Use Redis sorted sets for time-series: `traffic:customer:{customer_id}:history`
  - Score: Unix timestamp
  - Value: JSON traffic data
- Set TTL: 24 hours
- Provide methods:
  - `GetLatestTraffic(customerID) (*TrafficData, error)`
  - `GetTrafficHistory(customerID, from, to time.Time) ([]TrafficData, error)`

Start as background goroutine in `app.go`.

---

### Component: HTTP Layer (Inbound Adapters)

#### [NEW] customer_auth.go

Location: `internal/adapter/inbound/gin/customer_auth.go`

HTTP handlers:
- `CustomerLogin(c *gin.Context)` - POST `/v1/customer/auth/login`
- `CustomerLogout(c *gin.Context)` - POST `/v1/customer/auth/logout`
- `RefreshToken(c *gin.Context)` - POST `/v1/customer/auth/refresh`
- `GetProfile(c *gin.Context)` - GET `/v1/customer/auth/profile`

#### [NEW] customer_portal.go

Location: `internal/adapter/inbound/gin/customer_portal.go`

HTTP handlers:
- `GetTrafficStats(c *gin.Context)` - GET `/v1/customer/portal/traffic`
- `StreamTraffic(c *gin.Context)` - GET `/v1/customer/portal/traffic/stream` (WebSocket)
- `ResetSession(c *gin.Context)` - POST `/v1/customer/portal/session/reset`
- `GetUsageHistory(c *gin.Context)` - GET `/v1/customer/portal/usage/history`
- `UpdateProfile(c *gin.Context)` - PUT `/v1/customer/portal/profile` (name, phone, address only)

#### [NEW] public_registration.go

Location: `internal/adapter/inbound/gin/public_registration.go`

HTTP handlers:
- `GetTenantInfo(c *gin.Context)` - GET `/v1/public/tenant/:slug`
  - Returns branding info (name, logo, available profiles)
- `PublicRegister(c *gin.Context)` - POST `/v1/public/register/:slug`
  - Create prospect with password hash
  - Return success message (awaiting approval)

#### [MODIFY] [route.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/adapter/inbound/gin/route.go)

Add routes:

**Public routes (no auth):**
```go
public.GET("/tenant/:slug", port.PublicRegistration().GetTenantInfo)
public.POST("/register/:slug", port.PublicRegistration().PublicRegister)
```

**Customer auth routes:**
```go
customerAuth := v1.Group("/customer/auth")
customerAuth.POST("/login", port.CustomerAuth().CustomerLogin)
customerAuth.POST("/logout", middlewareAdapter.CustomerAuth, port.CustomerAuth().CustomerLogout)
customerAuth.POST("/refresh", port.CustomerAuth().RefreshToken)
customerAuth.GET("/profile", middlewareAdapter.CustomerAuth, port.CustomerAuth().GetProfile)
```

**Customer portal routes (require CustomerAuth middleware):**
```go
portal := v1.Group("/customer/portal")
portal.Use(middlewareAdapter.CustomerAuth())
{
  portal.GET("/traffic", port.CustomerPortal().GetTrafficStats)
  portal.GET("/traffic/stream", port.CustomerPortal().StreamTraffic)
  portal.POST("/session/reset", port.CustomerPortal().ResetSession)
  portal.GET("/usage/history", port.CustomerPortal().GetUsageHistory)
  portal.PUT("/profile", port.CustomerPortal().UpdateProfile)
}
```

---

### Component: Middleware

#### [MODIFY] [middleware.go](file:///c:/Users/masji/web/MikroBill-TA/mikrotik_billing_api/internal/adapter/inbound/gin/middleware.go)

Add new middleware:
- `CustomerAuth() gin.HandlerFunc`
  - Validate customer JWT token
  - Extract customer_id and tenant_id from token
  - Inject into Gin context
  - Verify customer status is "active"
  - Ensure tenant isolation (customer can only access their tenant's data)

Update existing:
- Ensure `TenantContext` middleware doesn't conflict with CustomerAuth

---

### Component: Redis Cache Keys

#### [NEW] traffic_cache_keys.go

Location: `internal/adapter/outbound/redis/traffic_cache_keys.go`

Define keys:
- `CacheTrafficLatest = "traffic:customer:%s:latest"` - latest traffic for customer
- `CacheTrafficHistory = "traffic:customer:%s:history"` - sorted set for historical data
- `CacheTrafficLive = "traffic:customer:%s:live"` - current live stream subscribers

---

## Verification Plan

### Automated Tests

#### 1. Unit Tests - Customer Domain

**File**: `internal/domain/customer/domain_test.go`

Test scenarios to add:
- `TestRegisterProspect_WithPasswordHash` - Verify password is hashed and stored
- `TestApproveProspect_PublishesToRabbitMQ` - Mock RabbitMQ, verify message published
- `TestApproveProspect_SetsProvisioningStatus` - Verify status updated to "provisioning"

**Run command**:
```bash
cd internal/domain/customer
go test -v -run "TestRegisterProspect|TestApproveProspect"
```

#### 2. Unit Tests - Customer Portal Domain

**File**: `internal/domain/customer_portal/domain_test.go` (NEW)

Test scenarios:
- `TestCustomerLogin_ValidCredentials` - Successful login
- `TestCustomerLogin_InvalidPassword` - Login fails with wrong password
- `TestCustomerLogin_InactiveCustomer` - Cannot login if status != 'active'
- `TestGetTrafficStats_FetchFromRedis` - Verify Redis cache hit

**Run command**:
```bash
cd internal/domain/customer_portal
go test -v
```

#### 3. Integration Tests - Provisioning Worker

**File**: `internal/adapter/inbound/rabbitmq/provisioning_worker_test.go` (NEW)

Requires: Running RabbitMQ and PostgreSQL (test containers or docker-compose)

Test scenarios:
- Publish provisioning message
- Verify worker picks up message
- Mock MikroTik API to return success
- Verify customer status updated correctly

**Run command**:
```bash
# Start test dependencies
docker-compose -f docker-compose.test.yml up -d

# Run integration tests
go test -v ./internal/adapter/inbound/rabbitmq/... -tags=integration
```

### Manual Testing

#### 1. Public Registration Flow

1. Start the application: `make run`
2. Get tenant info:
   ```bash
   curl -X GET http://localhost:8080/v1/public/tenant/demo-tenant
   ```
   **Expected**: Returns tenant branding and available profiles
   
3. Register as prospect:
   ```bash
   curl -X POST http://localhost:8080/v1/public/register/demo-tenant \
     -H "Content-Type: application/json" \
     -d '{
       "username": "testuser",
       "password": "securepass123",
       "name": "Test User",
       "phone": "081234567890",
       "email": "test@example.com",
       "profile_id": "uuid-of-profile",
       "service_type": "pppoe"
     }'
   ```
   **Expected**: Status 201, returns prospect created, status="prospect"

4. Admin approves prospect via internal API (already exists):
   ```bash
   curl -X POST http://localhost:8080/v1/internal/customer/prospects/approve \
     -H "Authorization: Bearer {admin-token}" \
     -H "Content-Type: application/json" \
     -d '{
       "customer_id": "prospect-uuid",
       "billing_day": 1,
       "auto_suspension": true
     }'
   ```
   **Expected**: Status 200, customer status="provisioning"

5. Check RabbitMQ management UI: Verify message in `customer.provisioning` queue

6. Check customer status after ~5 seconds:
   ```bash
   curl -X GET http://localhost:8080/v1/internal/customer/{id} \
     -H "Authorization: Bearer {admin-token}"
   ```
   **Expected**: Status="active", mikrotik_object_id populated

#### 2. Customer Portal Login & Traffic

1. Customer logs in:
   ```bash
   curl -X POST http://localhost:8080/v1/customer/auth/login \
     -H "Content-Type: application/json" \
     -d '{
       "username": " testuser",
       "password": "securepass123"
     }'
   ```
   **Expected**: Returns JWT access_token and refresh_token

2. Get traffic stats:
   ```bash
   curl -X GET http://localhost:8080/v1/customer/portal/traffic \
     -H "Authorization: Bearer {customer-token}"
   ```
   **Expected**: Returns latest traffic data from Redis

3. Reset session:
   ```bash
   curl -X POST http://localhost:8080/v1/customer/portal/session/reset \
     -H "Authorization: Bearer {customer-token}"
   ```
   **Expected**: Status 200, customer's PPP session disconnected

#### 3. Security & Isolation Testing

1. Customer A logs in, gets token
2. Customer A tries to access Customer B's data:
   ```bash
   curl -X GET http://localhost:8080/v1/customer/portal/traffic \
     -H "Authorization: Bearer {customer-a-token}" \
     -H "X-Customer-ID: {customer-b-id}"
   ```
   **Expected**: Status 403 Forbidden (middleware blocks cross-customer access)

3. Customer from Tenant A tries to login with credentials from Tenant B:
   **Expected**: Status 401 Unauthorized (tenant isolation enforced)

---

## Redis Cache Strategy

**Traffic Data Aggregation**:
1. Monitor domain publishes to `mikrotik:traffic:customers` (already implemented)
2. Traffic Aggregator subscribes and processes:
   - Stores latest: `traffic:customer:{id}:latest` (hash, TTL 5 min)
   - Stores history: `traffic:customer:{id}:history` (sorted set by timestamp, TTL 24h)
3. Customer Portal reads from cache (fast, no MikroTik query needed)

**Session Storage**:
- Key: `customer:session:{token_hash}`
- Value: JSON {customer_id, tenant_id, expires_at}
- TTL: Same as JWT expiry

---

## Security Considerations

1. **Password Hashing**: Use bcrypt with cost 12 for customer passwords
2. **JWT Tokens**: Separate signing key for customer tokens vs admin tokens
3. **Rate Limiting**: 
   - Public registration: 5 requests per IP per hour
   - Customer login: 10 attempts per username per hour
4. **Tenant Isolation**: 
   - Middleware MUST verify customer.tenant_id matches JWT tenant claim
   - Database queries MUST include tenant_id filter
5. **Input Validation**: All public endpoints have strict validation (already using Gin binding)

---

## Migration Plan

1. Run migration `14_customer_portal_support.go`
2. Restart application (workers start automatically)
3. Existing prospects: One-time script to reset them (password hash missing) OR require re-registration
4. Monitor RabbitMQ queues to ensure workers are consuming

---

## Rollback Strategy

If issues arise:
1. Revert migration `14_customer_portal_support.go`
2. Comment out worker startup in `app.go`
3. Revert `ApproveProspect` to direct MikroTik API call (keep synchronous)
4. Remove customer portal routes from `route.go`
